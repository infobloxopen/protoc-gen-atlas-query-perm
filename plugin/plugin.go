package plugin

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/gogo/protobuf/proto"
	"github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"

	"github.com/infobloxopen/atlas-app-toolkit/query"
	"github.com/infobloxopen/protoc-gen-atlas-query-perm/options"
)

const (
	filtering             = ".infoblox.api.Filtering"
	sorting               = ".infoblox.api.Sorting"
	permissionSuffix      = "MessagesRequiredValidation"
	methodFilteringSuffix = "MethodsRequiredFilteringValidation"
	methodSortingSuffix   = "MethodsRequiredSortingValidation"

	protoTypeTimestamp   = ".google.protobuf.Timestamp"
	protoTypeUUID        = ".gorm.types.UUID"
	protoTypeUUIDValue   = ".gorm.types.UUIDValue"
	protoTypeResource    = ".gorm.types.Identifier"
	protoTypeInet        = ".gorm.types.InetValue"
	protoTypeStringValue = ".google.protobuf.StringValue"
	protoTypeDoubleValue = ".google.protobuf.DoubleValue"
	protoTypeFloatValue  = ".google.protobuf.FloatValue"
	protoTypeInt32Value  = ".google.protobuf.Int32Value"
	protoTypeInt64Value  = ".google.protobuf.Int64Value"
	protoTypeUInt32Value = ".google.protobuf.UInt32Value"
	protoTypeUInt64Value = ".google.protobuf.UInt64Value"
)

// PermPlugin implements the plugin interface and creates validations for collection operation parameters code from .protos
type PermPlugin struct {
	*generator.Generator
	currentFile                            *generator.FileDescriptor
	messagePermissionsData                 string
	requiredFilteringValidationMethodsData string
	requiredSortingValidationMethodsData   string
}

func (p *PermPlugin) setFile(file *generator.FileDescriptor) {
	p.currentFile = file
	// p.Generator.SetFile(file.FileDescriptorProto)

	baseFileName := filepath.Base(file.GetName())
	p.messagePermissionsData = strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + permissionSuffix
	p.requiredFilteringValidationMethodsData = strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + methodFilteringSuffix
	p.requiredSortingValidationMethodsData = strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName)) + methodSortingSuffix

}

// Name identifies the plugin
func (p *PermPlugin) Name() string {
	return "atlas-query-perm"
}

// Init is called once after data structures are built but before
// code generation begins.
func (p *PermPlugin) Init(g *generator.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file,
// except for the imports, by calling the generator's methods P, In, and Out.
func (p *PermPlugin) Generate(file *generator.FileDescriptor) {
	p.setFile(file)
	p.genValidationData()
	p.genValidationFunc()
}

func (p *PermPlugin) genValidationData() {
	messagesByName := map[string]*generator.Descriptor{}
	msgRequireValidations := map[string]struct{}{}
	msgWithFilteringField := map[string]struct{}{}
	msgWithSortingField := map[string]struct{}{}

	packageName := p.currentFile.Package

	// generate message validation data
	p.P(`var `, p.messagePermissionsData, ` = map[string]map[string]options.FilteringOption{`)
	for _, msg := range p.currentFile.Messages() {
		fullMsgName := fmt.Sprintf(".%s.%s", *packageName, generator.CamelCaseSlice(msg.TypeName()))
		messagesByName[fullMsgName] = msg

		hasFiltering, hasSorting := p.generateMessagePermissions(msg)

		msgRequireValidations[fullMsgName] = struct{}{}

		if hasFiltering {
			msgWithFilteringField[fullMsgName] = struct{}{}
		}
		if hasSorting {
			msgWithSortingField[fullMsgName] = struct{}{}
		}
	}
	p.P(`}`)

	data := map[string]map[string]struct{}{
		p.requiredFilteringValidationMethodsData: msgWithFilteringField,
		p.requiredSortingValidationMethodsData:   msgWithSortingField,
	}

	for prefix, reqValidation := range data {
		// generate methods required validation data
		p.P(`var `, prefix, ` = map[string]string{`)
		for _, srv := range p.currentFile.GetService() {
			for _, method := range srv.GetMethod() {

				_, hasFilteringSorting := reqValidation[method.GetInputType()]
				msg, ok := messagesByName[method.GetOutputType()]
				if !ok {
					continue
				}
				msgFieldType := p.hasRequiredValidationField(msg, msgRequireValidations)
				if hasFilteringSorting && len(msgFieldType) > 0 {
					p.P(`"`, fmt.Sprintf("/%s.%s/%s", *packageName, srv.GetName(), method.GetName()), `": "`, strings.TrimLeft(msgFieldType, "."+*packageName), `",`)
				}
			}
		}
		p.P(`}`)
	}

}

func (p *PermPlugin) hasRequiredValidationField(msg *generator.Descriptor, requireValidations map[string]struct{}) string {
	for _, msgField := range msg.GetField() {
		if _, ok := requireValidations[msgField.GetTypeName()]; ok {
			return msgField.GetTypeName()
		}
	}
	return ""
}

func (p *PermPlugin) generateMessagePermissions(msg *generator.Descriptor) (bool, bool) {
	msgTypeName := generator.CamelCaseSlice(msg.TypeName())
	hasFilteringField := false
	hasSortingField := false

	p.P(`"`, msgTypeName, `": {`)
	for _, msgField := range msg.GetField() {

		if msgField.GetTypeName() == filtering {
			hasFilteringField = true
		}

		if msgField.GetTypeName() == sorting {
			hasSortingField = true
		}

		permissionOpts := getFieldPermissionsOption(msgField)

		msgFieldName := msgField.GetName()
		denyOps, filterType, err := getDenyOperations(msgField)
		if err != nil {
			p.Fail(fmt.Sprintf(`Error for message '%s': %s`, msgTypeName, err.Error()))
		}
		if filterType == "" {
			continue
		}
		var s string
		if permissionOpts.GetDisableSorting() {
			s = `DisableSorting: true,`
		}
		var f string
		if len(denyOps) != 0 {
			f = `Deny: []string{"` + strings.Join(denyOps, `","`) + `"},`
		}
		t := fmt.Sprintf(`FilterType: "%s"`, filterType)
		p.P(`"`, msgFieldName, `": options.FilteringOption{`+s+f+t+`},`)
	}
	p.P(`},`)
	return hasFilteringField, hasSortingField
}

func getFieldPermissionsOption(field *descriptor.FieldDescriptorProto) *options.CollectionPermissions {
	if field.Options == nil {
		return nil
	}
	v, err := proto.GetExtension(field.Options, options.E_Permissions)
	if err != nil {
		return nil
	}
	opts, ok := v.(*options.CollectionPermissions)
	if !ok {
		return nil
	}
	return opts
}

// getDenyOperations - returns list of denied operations and filter type or error
func getDenyOperations(field *descriptor.FieldDescriptorProto) ([]string, string, error) {
	res := []string{}

	permissionOpts := getFieldPermissionsOption(field)
	fieldName := field.GetName()

	f := permissionOpts.GetFilters()
	opsAllowed := f.GetAllow()
	opsDenied := f.GetDeny()

	filterType := permissionOpts.GetFilterType()

	if filterType == options.CollectionPermissions_DEFAULT {
		if field.IsRepeated() {
			return nil, "", nil
		}
		switch field.GetType() {
		case descriptor.FieldDescriptorProto_TYPE_STRING:
			filterType = options.CollectionPermissions_STRING
		case descriptor.FieldDescriptorProto_TYPE_ENUM:
			filterType = options.CollectionPermissions_STRING
		case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
			descriptor.FieldDescriptorProto_TYPE_FLOAT,
			descriptor.FieldDescriptorProto_TYPE_INT32,
			descriptor.FieldDescriptorProto_TYPE_INT64,
			descriptor.FieldDescriptorProto_TYPE_SINT32,
			descriptor.FieldDescriptorProto_TYPE_SINT64,
			descriptor.FieldDescriptorProto_TYPE_UINT32,
			descriptor.FieldDescriptorProto_TYPE_UINT64:
			filterType = options.CollectionPermissions_NUMBER
		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
			switch field.GetTypeName() {
			case protoTypeResource,
				protoTypeTimestamp,
				protoTypeUUID,
				protoTypeUUIDValue,
				protoTypeInet,
				protoTypeStringValue:
				filterType = options.CollectionPermissions_STRING
			case protoTypeDoubleValue,
				protoTypeFloatValue,
				protoTypeInt32Value,
				protoTypeInt64Value,
				protoTypeUInt32Value,
				protoTypeUInt64Value:
				filterType = options.CollectionPermissions_NUMBER
			default:
				return nil, "", nil
			}
		default:
			return nil, "", nil
		}
	}

	if len(opsAllowed) == 0 && len(opsDenied) == 0 {
		return nil, filterType.String(), nil
	}

	var supportedOps map[string]int32
	if filterType == options.CollectionPermissions_NUMBER {
		supportedOps = query.NumberCondition_Type_value
	} else if filterType == options.CollectionPermissions_STRING {
		supportedOps = query.StringCondition_Type_value
	}

	ops := opsAllowed
	if len(opsDenied) > 0 {
		ops = opsDenied
	}

	vals := strings.Split(ops, ",")
	for _, item := range vals {
		item := strings.TrimSpace(item)
		_, ok := supportedOps[item]
		if !ok && item != "ALL" {
			return nil, "", fmt.Errorf("'%s' is unknown permission operation for field '%s'", item, fieldName)
		}
	}

	if ops == opsAllowed {
	OUTER:
		for op := range supportedOps {
			found := false
			for _, allowedOp := range vals {
				if allowedOp == "ALL" {
					res = nil
					break OUTER
				}
				if op == allowedOp {
					found = true
					break
				}
			}
			if !found {
				res = append(res, op)
			}
		}
	} else {
		res = vals
		for _, op := range vals {
			if op == "ALL" {
				res = []string{"ALL"}
				break
			}
		}
	}
	return res, filterType.String(), nil
}

func (p *PermPlugin) genValidationFunc() {
	p.P(`func Validate(f *query.Filtering, p *query.Sorting, methodName string) error {`)
	p.P(`perm, ok := `, p.requiredFilteringValidationMethodsData, `[methodName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`res := options.ValidateFilteringPermissions(f, perm, `, p.messagePermissionsData, `)`)
	p.P(`if res != nil { return res}`)
	p.P(`perm, ok = `, p.requiredSortingValidationMethodsData, `[methodName]`)
	p.P(`if !ok {`)
	p.P(`return nil`)
	p.P(`}`)
	p.P(`res = options.ValidateSortingPermissions(p, perm, `, p.messagePermissionsData, `)`)
	p.P(`if res != nil { return res}`)
	p.P(`return nil`)
	p.P(`}`)
}

func (p *PermPlugin) CleanFiles(response *plugin.CodeGeneratorResponse) {
	for i := 0; i < len(response.File); i++ {
		file := response.File[i]
		file.Content = CleanImports(file.Content)
	}
}
